# 系统快捷操作

## 快捷键（系统）

```vim 
 *             | 向下查找并高亮显示
 #             | 向上查找并高亮显示
 g + d         | 高亮显示光标所属单词，“n” 查找！
 tab + tab + * | 选中字符串
 vip           | 快速选择段落
 =             | 框选脚本 快速格式化
```

## 快捷键（自定义）

{{{
  


  
}}}

```vim 
  jj  |  进入normal模式
  <C-b>n  | 下一个缓冲区
  <C-b>p  | 上一个缓存区
  <C-a>   |  <Home>
  <C-e>   |  <End>
  <C-p>   |  <Up>
  <C-n>   |  <Dn>
  <C-b>   |  <Lf>
  <C-f>   |  <Rt>
  <C-d>   |  <Del>
```

## 功能 - 导航 
 ctrl+f,ctrl+b 向下翻页，向上翻页
 ctrl+d,ctrl+u 向下半翻页，向上半翻页
 $ 移动行尾
 0 移动行首
 w 移动下一个词
 b 移动到上一个词
 gg 跳到文档的开始处
 G  跳到文档的末尾
 %  跳到匹配的括号处（\"{ }\"\"[]\"\"()\")
 ctrl+i,tab 跳到下一个jump point
 ctrl+o 跳到上一个jump point

 23gg,23G,:23 跳到第23行
 ctrl+i,tab 跳到下一个跳点(Jump Point)
 ctrl+o 跳到上一个跳点

## 快速设置 设置编码

```vim 
  :set encoding              | 查看终端显示编码（默认是根据你的locale选择.）
  :set encoding=UTF-8        | 设置终端显示编码
  :set fileencoding=UTF-8    | 设置当前编辑文件字符编码
  :set fileencodings         | 字符编码列表
  :set termencoding          | 终端使用的编码
```

## 功能 - 分屏

```vim
: vim -O3 file1 file3 file3 | 垂直分割3分屏
: vim -o2 file1 file2       | 水瓶分割2分屏
: v(split) file             | 水平分屏打开文件
: s(plit) file              | 垂直分屏打开文件
: new/vnew 创建一个新的窗口
: sf {filename} 在新窗口中打开filename
: close  关闭当前窗口
: only  关闭除当前窗口外所有窗口
: ball   平铺所有buffer
```
C-W s       | 水瓶分屏打开文件
C-W v       | 垂直分屏打开文件
C-w c(lose) | 关闭分屏
C-w w       | 切换分屏
C-w h       | 左 移动光标
C-w j       | 下 移动光标
C-w k       | 上 移动光标
C-w l       | 右 移动光标
C-w t       | 顶部 
C-w b       | 底部

C-w <       | 左移动大小
C-w >       | 右移动大小
C-w +       | 上移动大小
C-w -       | 下移动大小
C-w =       | 恢复均等




## 功能 - 折叠
> 每种折叠方法不兼容
+----------+--------------------+
| 折叠方法 | 描述               |
+----------+--------------------|
| manual   | 手工折叠           |
| indent   | 缩进折叠           |
| marker   | 标记折叠           |
| syntax   | 语法折叠           |
| expr     | 表达式折叠         |
| diff     | 没有更改的文件折叠 |
+----------+--------------------+

```vim 
 zi               | 打开/禁用折叠
 zn               | 禁用折叠
 zN               | 启用折叠
                  |
 zf               | 创建折叠
 zf20G            | 当前行折叠到第20行
 zfgg             | 当前行折叠到文件开始
 zf%              | 折叠到匹配符号
 zfa(             | 折叠括号（比如()、[]、{}、><等）包围的区域
 zd               | manual,marker 删除当前折叠 delete
 zD               | manual,marker 删除当前折叠,嵌套折叠
                  |
 zr               | 一次打开所有折叠
 zR               | 打开所有折叠及嵌套折折叠
 zm               | 一次关闭所有折叠
 zM               | 关闭所有折叠及嵌套折叠
                  |
 za               | 打开/关闭当前折叠
 zo               | 打开折叠 open
 zc               | 关闭折叠 close
                  |
 zE               | manual,marker  删除所有折叠
 zj               | 移动到下一个折叠
 zk               | 移动到上一个折叠
:set fdm=syntax   | 切换折叠方案
:mkview           | 保存当前折叠
:loadview         | 载入当前折叠
```





## 常用操作- 去除^M
>基于 DOS/Windows 的文本文件在每一行末尾有一个 CR（回车）和 LF（换行）
> UNIX 文本只有一个换行
> 如果win下的文档上传到linux，每行的结尾都会出现一个^M，(^M是ctrl+v,ctrl+m) 
> 如果是单个文档的话，可以用vi打开，执行 :%s/^M//g　来去掉^M
```
参考: https://www.zhihu.com/question/22130727
:%s/\r//gc  | 去除^M


```



# 插件快捷操作
 
## 常用快捷键自定义

```vim
 ;tm | 标格模式
 ;a= | =号对齐
 ;f  | 快速搜索
 F2  | 打开winmanager
 F4  | 切换头文件和实现文件
 F12 | 下一个主题
 F11 | 上一个主题
[[   | 跳转到折叠开头
]]   | 跳转到折叠结尾
```

## 自动输入括号

```vim 

 Old text              | Command           | New text ~               |
 ----------------------+-------------------+--------------------------+--
 my $str = *whee!;     | vllllS'           | my $str = 'whee!';       | 框选  S 括号

 "Hello *world!"       | ds"               | Hello world!             |
 (123+4*56)/2          | ds)               | 123+456/2                |
 <div>Yo!*</div>       | dst               | Yo!                      |

 "Hello *world!"       | cs"'              | 'Hello world!'           |
 "Hello *world!"       | cs"<q>            | <q>Hello world!</q>      |
 (123+4*56)/2          | cs)]              | [123+456]/2              |
 (123+4*56)/2          | cs)[              | [123+456]/2              |
 [123+4*56]/2          | cs])              | (123+456)/2              |
 <div>Yo!*</div>       | cst<p>            | <p>Yo!</p>               |
 
 Hello w*orld!         | ysiw)             | Hello (world)!           |
 Hello w*orld!         | ysiw<q>           | Hello <q>world</q>!      |
 Hello w*orld!         | yssB              | {Hello world!}           |
 Hello w*orld!         | yssb              | (Hello world!)           |
 Hello w*orld!         | yss)              | (Hello world!)  整行添加 |
 if *x>3 {             | ysW(              | if ( x>3 ) {             |
 *"hello"              | ysWfprint<cr>     | print("hello")           | <cr> 表示回车
 *"hello"              | ysWFprint<cr>     | print( "hello" )         | <cr> 表示回车
 *"hello"              | ysW<C-f>print<cr> | (print "hello")          | <cr> 表示回车<C-F> 表示ctrl+f
```


## minimap

```vim
;mo | 打开
;mu | 刷新
;mc | 关闭
;mm | 切换
```

## Tabularize
```vim
;a  |开启对齐
;a= | 等号对齐
```




## DrawIt
```vim
  ;di | start DrawIt 
  ;ds | stop  DrawIt 
```


## vim-bookmarks

```vim 
  mm 添加/删除书签
  mi 添加编辑书签mm
  mn 跳转到当前buffer的下一个书签
  mp 跳转到上一个书签
  ma 在quickfix 窗口列出所有书签
  mc 清除当前buffer所有书签
  mx 清除所有buffer 内的书签
  :BookmarkSave < file>  : 保存到文件
  :BookmarkLoad <file > : 从文件读取
```

## 插件-Graphviz
  :Graphviz            ; 打开编译后文件(默认pdf)
  :Graphviz png        ; 打开编译后文件(png)
  :GraphvizCompile     ; 编译(默认pdf)
  :GraphvizComplie png ; 编译成(png)
  :Graphviz!           ; 编译并打开

## 导航


  选中上层括号
  vi(，va(等text object可以选中包围括号内的内容
  vi(i( 可以选择上两层括号的内容
  vi(i(i(可以选择上面三层括号的内容



# 文件操作
:e  重载文件
:e!  强制重载
# 查找替换:

 # 从光标向后查找整个关键词
 * 从光标向前查找整个关键词
 g# 从光标向后查找关键词
 g* 从光标向前查找关键词
 fx,tx,Fx,Tx 在当前行查找字符

# 查找替换例子:
 : s/SEARCH/REPLACE
 : s/If/Since 将下一个\"If\"换成\"Since\"
 : %s/If/Since 将全部\"If\"换成\"Since\"
 : 1,3 s/If/Since/g 只对1,3行有效,如无前缀,只对当前行有效

# 表达式:
 . 代替一个字符
 * 表示一个或多个字符的重复
 
 /d.*an 可以匹配 dan, divan, debian
 
 单词边界:
 指定单词边界: \< 和 \>
 如: /\<d[a-z]*an\>    匹配以d开始,中间包含任意个小写字母,以an结束的单词

 /\$[0-9]*\.[0-9][0-9] 匹配查找 $XX...X.XX这要的数字,有且只有两位小数的

# 常用的编辑命令:
 a, i   在光标后插入, 在光标前插入
 dd  删除一行
 cc,S  删除一行后进入insert模式
 dw  删除一个单词
 cw  删除一个单词后进入insert模式
 x,dl  删除一个字符
 s,cl  删除一个字符后进入insert模式

 p  粘贴
 xp  交换两个字符
 ddp  交换两行

 y  复制
 yy  复制一行
 u  撤消
 ctrl+r  重做
 .  重复上一次修改
 
 ctrl+r  重做
 .  重复上一次修改
 

## 比较文档

不少文本比较工具都要求先将需要比较的文本保持成文件，再比较文件。在vim里你可以先粘贴进文本一（不用保存），然后用:new （水平分屏）或:vnew （垂直分屏）创建新buffer，在粘贴进去文本二。然后分别在两个buffer中执行
:diffthis     即可直接比较
:diffoff      退出比较模式

## 重复操作（宏操作）:
 q[a-z]  开始记录操作,记录到寄存器[a-z]中
 q  停止记录操作
 @[a-z]  执行寄存器中的操作
 @@  执行最近寄存器中记录的操作
 例子： 一个缓冲区有两行：
  sys/types.h
  stdio.h
 -->要改为：
  #include <sys/types.h>
  #include <stdio.h>
 操作如下：
  qa #开始记录
  ^ #移动行首
  i #进入insert模式
  #include < #输入内容
  $ #移动行尾
  i #进入insert模式
  > #输入内容
  q #停止记录

  移动另一行：
  @a即可执行相同的操作
 
# Visual Mode操作:
 ctrl+v 进入基于块的可视模式
 v  进入基于字符的可视模式
 V  进入基于行的可视模式
 
 c  删除选定的块
 I{string}<ESC> 选定块后按大写的I，输入字符串，再按ESC，
可以在块内每一行插入相同的内容

# 跳到声明处:
 [[  向前跳到顶格的第一个\"{\"
 []  向前跳到顶格的第一个\"}\"
 ][  向后跳到顶格的第一个\"{\"
 ]]  向后跳到顶格的第一个\"}\"
 [{  跳到本代码块(由{}界定)的开头
 [}  跳到本代码块的结尾

# Shell:
 :ctrl+z/suspend 在shell下是挂起vim; gui下是最小化窗口
 :!{command} 执行shell命令
 :shell  开一个新的shell
 
 保存vim状态(挂起?)：
 :mksession session.vim      保存当前vim状态
 :source session.vim         回复vim状态
 vim -S session.vim         启动vim时恢复session

fx：移动光标到当前行的下一个x处。很明显，x可以是任意一个字母，
而且你可以使用;来重复你的上一个f命令。

tx：和上面的命令类似，但是是移动到x的左边一个位置。（这真的很有用）
Fx：和fx类似，不过是往回找。
w：光标往前移动一个词。
b： 光标往后移动一个词。
0： 移动光标到当前行首。
^：移动光标到当前行的第一个字母位置。
$： 移动光标到行尾。
)：移动光标到下一个句子。
( ： 移动光标到上一个句子。

下面是一些在文件里面移动的命令：
<C-F>：向下移动一屏。
<C-B>：向上移动一屏。
G：到文件尾
numG：移动光标到指定的行（num）。（比如10G就是到第10行）

gg：到文件首
H：移动光标到屏幕上面
：移动光标到屏幕中间
L：移动光标到屏幕下面

*：读取光标处的字符串，并且移动光标到它再次出现的地方。
#：和上面的类似，但是是往反方向寻找。

/text：从当前光标处开始搜索字符串text，并且到达text出现的地方。
必须使用回车来开始这个搜索命令。如果想重复上次的搜索的话，按n。

？text：和上面类似，但是是反方向。
ma：在当前光标的位置标记一个书签，名字为a。书签名只能是小写字母。
你看不见书签的存在，但它确实已经在那里了。
`a：到书签a处。注意这个不是单引号，它一般位于大部分键盘的1的左边。
`.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。

# 高效的输入
使用关键词自动完成
VIM有一个非常漂亮的关键词自动完成系统。这表示，你可以输入一个长词的一部分，
然后按一下某个键，然后VIM就替你完成了这个长词的输入了。举个例子：你有
一个变量名为 iAmALongAndAwkwardVarName 在你写的代码的某个地方。
也许你不想每回都自己一个一个字母的去输入它。

使用关键词自动完成功能，你只需要输入开始几个字母（比如iAmAL），
然后按<C-N>（按住Ctrl，再按N）或者<C-P>。如果VIM没有给出你想要的词，
基本按，直到你满意为止，VIM会一直循环它找到的匹配的字符串。

聪明的进入插入模式
很多新手进入插入模式都只是用i。这样当然可以进入插入模式，但通常不是那么合适，
因为VIM提供了很多进入插入模式的命令。下面是最常用的一些：

i：在当前字符的左边插入
I：在当前行首插入
a：在当前字符的右边插入
A：在当前行尾插入
o：在当前行下面插入一个新行
O：在当前行上面插入一个新行

c{motion}：删除motion命令跨过的字符，并且进入插入模式。
比如：c$，这将会删除从光标位置到行尾的字符并且进入插入模式。ct！，
这会删除从光标位置到下一个叹号（但不包括），然后进入插入模式。
被删除的字符被存在了剪贴板里面，并且可以再粘贴出来。

d{motion}：和上面差不多，但是不进入插入模式。

有效的移动大段的文本
使用可视选择（visual selections）和合适的选择模式
不想最初的VI，VIM允许你高亮（选择）一些文本，并且进行操作。

这里有三种可视选择模式：
v：按字符选择。经常使用的模式，所以亲自尝试一下它。
V：按行选择。这在你想拷贝或者移动很多行的文本的时候特别有用。
<C-V>：按块选择。非常强大，只在很少的编辑器中才有这样的功能。
你可以选择一个矩形块，并且在这个矩形里面的文本会被高亮。

在选择模式的时候使用上面所述的方向键和命令（motion）。
比如，vwww，会高亮光标前面的三个词。Vjj将会高亮当前行以及下面两行。

在可视选择模式下剪切和拷贝
一旦你高亮了选区，你或许想进行一些操作：
d：剪贴选择的内容到剪贴板。
y：拷贝选择的内容到剪贴板。
c：剪贴选择的内容到剪贴板并且进入插入模式。

在非可视选择模式下剪切和拷贝
如果你很清楚的知道你想拷贝或者剪切什么，那你根本就不需要进入可视选择模式。
d{motion}：剪切motion命令跨过的字符到剪贴板。
比如，dw会剪切一个词而dfS会将从当前光标到下一个S之间的字符剪切至剪贴板。

y{motion}：和上面类似，不过是拷贝。
c{motion}：和d{motion}类似，不过最后进入插入模式。
dd：剪切当前行。
yy：拷贝当前行。
cc：剪切当前行并且进入插入模式。
D：剪切从光标位置到行尾到剪贴板。
Y：拷贝当前行。
C：和D类似，最后进入插入模式。
x：剪切当前字符到剪贴板。
s：和x类似，不过最后进入插入模式。

粘贴很简单，按p。
使用多重剪贴板

很多编辑器都只提供了一个剪贴板。VIM有很多。
剪贴板在VIM里面被称为寄存器（Registers）。
你可以列出当前定义的所有寄存器名和它们的内容，命令为\":reg\"。
最好使用小写字母来作为寄存器的名称，因为大写的有些被VIM占用了。

使用寄存器的命令为双引号“。

比如：我们要拷贝当前行到寄存器k。你应该按 \"kyy。
（你也可以使用 V\"ky。为什么这样也可以呢？）现在当前行应该已经存在了
寄存器k里面直到你又拷贝了一些东西进入寄存器k。现在你可以使用命令 \"kp 来
粘贴寄存器k里面的内容到你想要的位置。

避免重复
令人惊奇的 . 命令
在VI里面，输入 . (小数点符号），将会重复你给入的上一个命令。
比如，你上个命令为 \'dw\'（删除一个词），VI将会接着再删除一个词。

使用数字
使用数字也是VIM强大的而且很节省时间的重要特性之一。
在很多VIM的命令之前都可以使用一个数字，这个数字将会告诉VIM这个命令需要执行几次。

3j 将会把光标向下移动三行。
10dd 将会删除十行。
y3\" 将会拷贝从当前光标到第三个出现的引号之间的内容到剪贴板。

数字是扩展motion命令作用域非常有效的方法。
有时候，你会发现你自己在文章的每段或者每行都重复相同的一系列动作。
VIM允许你记录一个宏来完成你的特殊需要。

qregister：记录宏到寄存器register，这里register是任意的你的寄存器的名字。
比如qa，将会记录并且把宏存在寄存器a里面。

q：结束宏的记录。

@register：使用存在寄存器register的宏。比如@a，将会使用存在寄存器a里面的宏。

必须要记住的是，宏只记录了你的系列按键并且重复执行它们。
它们不是魔法。因为在VIM里面完成目的的方法有很多，
所以有时候你要小心选择命令来记录你的宏。因为它们会在所有你要执行它的地方执行。

]p：和p的功能差不多，但是它会自动调整被粘贴的文本的缩进去适应当前代码的位置。试一下！

%：匹配花括号，方括号，括号等。在一个括号的上面，然后按%，
鼠标就会出现在匹配的另外一半括号处。

>>：缩进所有选择的代码
<<：和上面类似，但是反缩进
gd：到达光标所在处函数或者变量的定义处。
K：在Man里面查找光标当前所在处的词。


